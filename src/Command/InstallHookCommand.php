<?php

namespace TestrailTools\Command;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

/**
 * Command to install pre-commit hook in target repository
 * 
 * @author Mykola Dolynskyi aka nop1984 <gospodin.p.zh@gmail.com>
 */
class InstallHookCommand extends Command
{
    protected function configure()
    {
        $this
            ->setName('install-hook')
            ->setDescription('Install pre-commit hook in target repository')
            ->addArgument('repo', InputArgument::OPTIONAL, 'Path to git repository', null)
            ->setHelp('This command installs a pre-commit git hook that automatically runs prepare-commit before each commit.');
    }
    
    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $output->writeln("=== Install Pre-Commit Hook ===");
        $output->writeln("");
        
        try {
            $repoPath = $input->getArgument('repo');
            
            if ($repoPath) {
                $repoRoot = $this->validateAndGetRepoRoot($repoPath, $output);
            } else {
                // Use GitService to find the parent repository (skipping branch-tools itself)
                $repoRoot = \TestrailTools\Service\GitService::detectParentRepository($output);
            }
            
            // Determine the relative path from repo root to branch-tools
            $branchToolsPath = realpath(__DIR__ . '/../../branch-tools');
            $relativePath = $this->getRelativePath($repoRoot, $branchToolsPath);
            
            $output->writeln("<info>Repository: {$repoRoot}</info>");
            $output->writeln("<info>Branch tools path: {$relativePath}</info>");
            $output->writeln("");
            
            // Create hooks directory if it doesn't exist
            $hooksDir = $repoRoot . '/.git/hooks';
            if (!is_dir($hooksDir)) {
                if (!mkdir($hooksDir, 0755, true)) {
                    throw new \Exception("Failed to create hooks directory: {$hooksDir}");
                }
                $output->writeln("<info>✓ Created hooks directory</info>");
            }

            // Ask if auto mode should be enabled (non-interactive)
            $helper = $this->getHelper('question');
            $question = new \Symfony\Component\Console\Question\ConfirmationQuestion(
                "\n<question>Enable auto-mode for this hook? (y/n)</question>\n" .
                "If enabled, upgrades build number automatically without prompts.\n" .
                "If disabled (default), prompts you to pick build number gaps interactively.\n" .
                "Auto mode? [y/N]: ", 
                false
            );
            $useAuto = $helper->ask($input, $output, $question);
            
            // Create the pre-commit hook
            $hookPath = $hooksDir . '/pre-commit';
            $hookContent = $this->generateHookContent($relativePath, $useAuto);
            
            // Check if hook already exists
            if (file_exists($hookPath)) {
                $existingContent = file_get_contents($hookPath);
                
                // Check if our hook is already installed
                if (strpos($existingContent, 'Auto-generated by branch-tools') !== false) {
                    $output->writeln("<comment>⚠️  Pre-commit hook already installed</comment>");
                    $output->writeln("");
                    $output->writeln("Hook location: {$hookPath}");
                    $output->writeln("");
                    $output->writeln("<comment>To reinstall, first remove: rm {$hookPath}</comment>");
                    return Command::SUCCESS;
                }
                
                // Backup existing hook
                $backupPath = $hookPath . '.backup.' . date('YmdHis');
                if (!copy($hookPath, $backupPath)) {
                    throw new \Exception("Failed to backup existing hook");
                }
                $output->writeln("<info>✓ Backed up existing hook to: {$backupPath}</info>");
            }
            
            // Write the hook
            if (file_put_contents($hookPath, $hookContent) === false) {
                throw new \Exception("Failed to write hook file");
            }
            
            // Make it executable
            if (!chmod($hookPath, 0755)) {
                throw new \Exception("Failed to make hook executable");
            }
            
            $output->writeln("<info>✓ Pre-commit hook installed successfully</info>");
            $output->writeln("");
            $output->writeln("Hook location: {$hookPath}");
            $output->writeln("");
            $output->writeln("<comment>The hook will now run automatically before each commit to:</comment>");
            $output->writeln("  • Update workflow YAML files (if on feature branch)");
            $output->writeln("  • Auto-increment and validate build.txt");
            $output->writeln("  • Auto-stage modified files");
            $output->writeln("");
            $output->writeln("<comment>To uninstall: rm {$hookPath}</comment>");
            
            return Command::SUCCESS;
            
        } catch (\Exception $e) {
            $output->writeln("<error>✗ Error: " . $e->getMessage() . "</error>");
            return Command::FAILURE;
        }
    }
    
    private function validateAndGetRepoRoot($path, $output)
    {
        // Resolve to absolute path
        $path = realpath($path);
        
        if ($path === false || !is_dir($path)) {
            throw new \Exception("Path does not exist or is not a directory: {$path}");
        }
        
        // Check if it's a git repository
        $originalDir = getcwd();
        chdir($path);
        
        $checkOutput = [];
        exec('git rev-parse --show-toplevel 2>&1', $checkOutput, $returnCode);
        
        if ($returnCode !== 0) {
            chdir($originalDir);
            throw new \Exception("Not a git repository: {$path}");
        }
        
        $repoRoot = trim($checkOutput[0]);
        chdir($originalDir);
        
        return $repoRoot;
    }
    
    private function getRelativePath($from, $to)
    {
        // Normalize paths
        $from = rtrim($from, '/');
        $to = rtrim($to, '/');
        
        $fromParts = explode('/', $from);
        $toParts = explode('/', $to);
        
        // Find common base
        $common = 0;
        $max = min(count($fromParts), count($toParts));
        
        for ($i = 0; $i < $max; $i++) {
            if ($fromParts[$i] !== $toParts[$i]) {
                break;
            }
            $common++;
        }
        
        // Build relative path
        $up = array_fill(0, count($fromParts) - $common, '..');
        $down = array_slice($toParts, $common);
        
        $relativeParts = array_merge($up, $down);
        
        return implode('/', $relativeParts);
    }
    
    private function generateHookContent($branchToolsRelativePath, $useAuto)
    {
        $autoFlag = $useAuto ? ' --auto' : '';
        $interactiveSetup = $useAuto ? '' : "\n# Interactive setup for terminal input\nexec < /dev/tty\n";

        return <<<HOOK
#!/bin/bash
#
# Git Pre-Commit Hook - Auto-generated by branch-tools
# 
# This hook automatically:
# 1. Updates workflow YAML files if on a feature branch
# 2. Auto-increments build.txt if needed
# 3. Validates build number is not taken in any remote branch
# 4. Auto-stages modified files (workflows and build.txt)
#
# To uninstall: rm .git/hooks/pre-commit
# To temporarily bypass: git commit --no-verify

# Get the repository root
REPO_ROOT=\$(git rev-parse --show-toplevel)
{$interactiveSetup}
# Run the prepare-commit command
"\${REPO_ROOT}/{$branchToolsRelativePath}" prepare-commit{$autoFlag}

# Capture exit code
EXIT_CODE=\$?

# If successful and files were modified, stage them
if [ \$EXIT_CODE -eq 0 ]; then
    # Check if workflow files were modified
    if git diff --name-only | grep -q ".github/workflows/"; then
        git add .github/workflows/set-gizmo-branch-var.yml .github/workflows/ci-build-with-kiuwan-analysis.yml 2>/dev/null
        echo "✓ Workflow files staged"
    fi
    
    # Check if build.txt was modified
    if git diff --name-only | grep -q "build.txt"; then
        git add build.txt 2>/dev/null
        echo "✓ build.txt staged"
    fi
fi

exit \$EXIT_CODE

HOOK;
    }
}
