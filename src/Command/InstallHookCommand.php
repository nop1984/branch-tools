<?php

namespace TestrailTools\Command;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

/**
 * Command to install pre-commit hook in target repository
 * 
 * @author Mykola Dolynskyi aka nop1984 <gospodin.p.zh@gmail.com>
 */
class InstallHookCommand extends Command
{
    protected function configure()
    {
        $this
            ->setName('install-hook')
            ->setDescription('Install git hooks (pre-commit and pre-push) in target repository')
            ->addArgument('repo', InputArgument::OPTIONAL, 'Path to git repository', null)
            ->setHelp('This command installs git hooks: pre-commit (runs prepare-commit) and pre-push (runs trigger-build).');
    }
    
    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $output->writeln("=== Install Git Hooks ===");
        $output->writeln("");
        
        try {
            $repoPath = $input->getArgument('repo');
            
            if ($repoPath) {
                $repoRoot = $this->validateAndGetRepoRoot($repoPath, $output);
            } else {
                // Use GitService to find the parent repository (skipping branch-tools itself)
                $repoRoot = \TestrailTools\Service\GitService::detectParentRepository($output);
            }
            
            // Determine the relative path from repo root to branch-tools
            $branchToolsPath = realpath(__DIR__ . '/../../branch-tools');
            $relativePath = $this->getRelativePath($repoRoot, $branchToolsPath);
            
            $output->writeln("<info>Repository: {$repoRoot}</info>");
            $output->writeln("<info>Branch tools path: {$relativePath}</info>");
            $output->writeln("");
            
            // Create hooks directory if it doesn't exist
            $hooksDir = $repoRoot . '/.git/hooks';
            if (!is_dir($hooksDir)) {
                if (!mkdir($hooksDir, 0755, true)) {
                    throw new \Exception("Failed to create hooks directory: {$hooksDir}");
                }
                $output->writeln("<info>âœ“ Created hooks directory</info>");
            }

            // Ask if auto mode should be enabled (non-interactive)
            $helper = $this->getHelper('question');
            $question = new \Symfony\Component\Console\Question\ConfirmationQuestion(
                "\n<question>Enable auto-mode for this hook? (y/n)</question>\n" .
                "If enabled, upgrades build number automatically without prompts.\n" .
                "If disabled (default), prompts you to pick build number gaps interactively.\n" .
                "Auto mode? [y/N]: ", 
                false
            );
            $useAuto = $helper->ask($input, $output, $question);
            
            // Create the pre-commit hook
            $hookPath = $hooksDir . '/pre-commit';
            $hookContent = $this->generateHookContent($relativePath, $useAuto);
            
            // Check if hook already exists
            if (file_exists($hookPath)) {
                $existingContent = file_get_contents($hookPath);
                
                // Check if our hook is already installed
                if (strpos($existingContent, 'Auto-generated by branch-tools') !== false) {
                    $output->writeln("<comment>âš ï¸  Pre-commit hook already installed</comment>");
                    // Don't return - continue to install pre-push hook
                } else {
                    // Backup existing hook
                    $backupPath = $hookPath . '.backup.' . date('YmdHis');
                    if (!copy($hookPath, $backupPath)) {
                        throw new \Exception("Failed to backup existing hook");
                    }
                    $output->writeln("<info>âœ“ Backed up existing hook to: {$backupPath}</info>");
                    
                    // Write the hook
                    if (file_put_contents($hookPath, $hookContent) === false) {
                        throw new \Exception("Failed to write hook file");
                    }
                    
                    // Make it executable
                    if (!chmod($hookPath, 0755)) {
                        throw new \Exception("Failed to make hook executable");
                    }
                    
                    $output->writeln("<info>âœ“ Pre-commit hook installed successfully</info>");
                }
            } else {
                // Write the hook
                if (file_put_contents($hookPath, $hookContent) === false) {
                    throw new \Exception("Failed to write hook file");
                }
                
                // Make it executable
                if (!chmod($hookPath, 0755)) {
                    throw new \Exception("Failed to make hook executable");
                }
                
                $output->writeln("<info>âœ“ Pre-commit hook installed successfully</info>");
            }
            
            // Now install the pre-push hook
            $prePushHookPath = $hooksDir . '/pre-push';
            $prePushHookContent = $this->generatePrePushHookContent($relativePath);
            
            // Check if pre-push hook already exists
            if (file_exists($prePushHookPath)) {
                $existingContent = file_get_contents($prePushHookPath);
                
                // Check if our hook is already installed
                if (strpos($existingContent, 'Auto-generated by branch-tools') !== false) {
                    $output->writeln("<comment>âš ï¸  Pre-push hook already installed</comment>");
                } else {
                    // Backup existing pre-push hook
                    $backupPath = $prePushHookPath . '.backup.' . date('YmdHis');
                    if (!copy($prePushHookPath, $backupPath)) {
                        throw new \Exception("Failed to backup existing pre-push hook");
                    }
                    $output->writeln("<info>âœ“ Backed up existing pre-push hook to: {$backupPath}</info>");
                    
                    // Write the pre-push hook
                    if (file_put_contents($prePushHookPath, $prePushHookContent) === false) {
                        throw new \Exception("Failed to write pre-push hook file");
                    }
                    
                    // Make it executable
                    if (!chmod($prePushHookPath, 0755)) {
                        throw new \Exception("Failed to make pre-push hook executable");
                    }
                    
                    $output->writeln("<info>âœ“ Pre-push hook installed successfully</info>");
                }
            } else {
                // Write the pre-push hook
                if (file_put_contents($prePushHookPath, $prePushHookContent) === false) {
                    throw new \Exception("Failed to write pre-push hook file");
                }
                
                // Make it executable
                if (!chmod($prePushHookPath, 0755)) {
                    throw new \Exception("Failed to make pre-push hook executable");
                }
                
                $output->writeln("<info>âœ“ Pre-push hook installed successfully</info>");
            }
            
            $output->writeln("");
            $output->writeln("Hook locations:");
            $output->writeln("  â€¢ Pre-commit: {$hookPath}");
            $output->writeln("  â€¢ Pre-push: {$prePushHookPath}");
            $output->writeln("");
            $output->writeln("<comment>Pre-commit hook will run before each commit to:</comment>");
            $output->writeln("  â€¢ Update workflow YAML files (if on feature branch)");
            $output->writeln("  â€¢ Auto-increment and validate build.txt");
            $output->writeln("  â€¢ Auto-stage modified files");
            $output->writeln("");
            $output->writeln("<comment>Pre-push hook will run before each push to:</comment>");
            $output->writeln("  â€¢ Ask if you want to trigger a CI/CD build");
            $output->writeln("  â€¢ Create an empty commit to trigger the build if requested");
            $output->writeln("  â€¢ Schedule automatic push in the background");
            $output->writeln("");
            $output->writeln("<comment>To uninstall: rm {$hookPath} {$prePushHookPath}</comment>");
            $output->writeln("<comment>To temporarily bypass: git commit --no-verify OR git push --no-verify</comment>");
            
            return Command::SUCCESS;
            
        } catch (\Exception $e) {
            $output->writeln("<error>âœ— Error: " . $e->getMessage() . "</error>");
            return Command::FAILURE;
        }
    }
    
    private function validateAndGetRepoRoot($path, $output)
    {
        // Resolve to absolute path
        $path = realpath($path);
        
        if ($path === false || !is_dir($path)) {
            throw new \Exception("Path does not exist or is not a directory: {$path}");
        }
        
        // Check if it's a git repository
        $originalDir = getcwd();
        chdir($path);
        
        $checkOutput = [];
        exec('git rev-parse --show-toplevel 2>&1', $checkOutput, $returnCode);
        
        if ($returnCode !== 0) {
            chdir($originalDir);
            throw new \Exception("Not a git repository: {$path}");
        }
        
        $repoRoot = trim($checkOutput[0]);
        chdir($originalDir);
        
        return $repoRoot;
    }
    
    private function getRelativePath($from, $to)
    {
        // Normalize paths
        $from = rtrim($from, '/');
        $to = rtrim($to, '/');
        
        $fromParts = explode('/', $from);
        $toParts = explode('/', $to);
        
        // Find common base
        $common = 0;
        $max = min(count($fromParts), count($toParts));
        
        for ($i = 0; $i < $max; $i++) {
            if ($fromParts[$i] !== $toParts[$i]) {
                break;
            }
            $common++;
        }
        
        // Build relative path
        $up = array_fill(0, count($fromParts) - $common, '..');
        $down = array_slice($toParts, $common);
        
        $relativeParts = array_merge($up, $down);
        
        return implode('/', $relativeParts);
    }
    
    private function generateHookContent($branchToolsRelativePath, $useAuto)
    {
        $autoFlag = $useAuto ? ' --auto' : '';
        $interactiveSetup = $useAuto ? '' : "\n# Interactive setup for terminal input\nexec < /dev/tty\n";

        return <<<HOOK
#!/bin/bash
#
# Git Pre-Commit Hook - Auto-generated by branch-tools
# 
# This hook automatically:
# 1. Updates workflow YAML files if on a feature branch
# 2. Auto-increments build.txt if needed
# 3. Validates build number is not taken in any remote branch
# 4. Auto-stages modified files (workflows and build.txt)
#
# To uninstall: rm .git/hooks/pre-commit
# To temporarily bypass: git commit --no-verify

# Get the repository root
REPO_ROOT=\$(git rev-parse --show-toplevel)
{$interactiveSetup}
# Run the prepare-commit command
"\${REPO_ROOT}/{$branchToolsRelativePath}" prepare-commit{$autoFlag}

# Capture exit code
EXIT_CODE=\$?

# If successful and files were modified, stage them
if [ \$EXIT_CODE -eq 0 ]; then
    # Check if workflow files were modified
    if git diff --name-only | grep -q ".github/workflows/"; then
        git add .github/workflows/set-gizmo-branch-var.yml .github/workflows/ci-build-with-kiuwan-analysis.yml 2>/dev/null
        echo "âœ“ Workflow files staged"
    fi
    
    # Check if build.txt was modified
    if git diff --name-only | grep -q "build.txt"; then
        git add build.txt 2>/dev/null
        echo "âœ“ build.txt staged"
    fi
fi

exit \$EXIT_CODE

HOOK;
    }
    
    private function generatePrePushHookContent($branchToolsRelativePath)
    {
        return <<<HOOK
#!/bin/bash
#
# Git Pre-Push Hook - Auto-generated by branch-tools
# 
# This hook automatically:
# 1. Asks if you want to trigger a CI/CD build before pushing
# 2. Creates an empty commit to trigger the build if requested
# 3. Monitors the background push and reports results
#
# To uninstall: rm .git/hooks/pre-push
# To temporarily bypass: git push --no-verify

# Get the repository root
REPO_ROOT=\$(git rev-parse --show-toplevel)

# Read branch-tools path from config file
BRANCH_TOOLS_CONFIG="\${REPO_ROOT}/.git/branch-tools-path"
if [ -f "\$BRANCH_TOOLS_CONFIG" ]; then
    BRANCH_TOOLS=\$(cat "\$BRANCH_TOOLS_CONFIG")
    if [ ! -x "\$BRANCH_TOOLS" ]; then
        echo "Error: branch-tools executable not found at configured path: \$BRANCH_TOOLS"
        echo "Please reinstall hooks by running: branch-tools install-hook"
        exit 1
    fi
else
    # Fallback to relative path
    BRANCH_TOOLS="\${REPO_ROOT}/{$branchToolsRelativePath}"
    if [ ! -x "\$BRANCH_TOOLS" ]; then
        echo "Error: branch-tools executable not found at: \$BRANCH_TOOLS"
        echo "Please install hooks by running: branch-tools install-hook"
        exit 1
    fi
fi

# Redirect stdin to TTY for interactive prompts
exec < /dev/tty

# Run trigger-build (interactive, no output capture)
"\${BRANCH_TOOLS}" trigger-build
EXIT_CODE=\$?

# If trigger-build returned failure (which means it scheduled an async push),
# Look for the most recent log file and monitor it
if [ \$EXIT_CODE -ne 0 ]; then
    LOG_FILE=\$(ls -t /tmp/git-async-*.log 2>/dev/null | head -1)
    
    echo ""
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo "âœ“ Push cancelled - trigger commit created and scheduled to push"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo ""
    echo "â„¹ï¸  Monitoring background push..."
    
    # Wait for the background process (max 5 seconds)
    WAIT_COUNT=0
    MAX_WAIT=5
    
    while [ \$WAIT_COUNT -lt \$MAX_WAIT ]; do
        if [ -f "\$LOG_FILE" ] && ! pgrep -f "git.*push.*\$REPO_ROOT" > /dev/null 2>&1; then
            # Process finished, check results
            sleep 0.5  # Small delay to ensure file is fully written
            
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "Background Push Results:"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            cat "\$LOG_FILE"
            echo ""
            
            # Check if push was successful
            if grep -q "error:\|fatal:\|failed" "\$LOG_FILE"; then
                echo "âŒ Push failed! Please check the error above."
                echo ""
                echo "Suggested next steps:"
                echo "  1. Review the error message"
                echo "  2. Fix any issues - e.g., pull remote changes if needed"
                echo "  3. Try pushing again: git push"
                echo "  4. Or push without trigger: git push --no-verify"
                echo ""
            else
                echo "âœ… Push completed successfully!"
                echo ""
                BRANCH=\$(git rev-parse --abbrev-ref HEAD)
                echo "Next steps:"
                echo "  â€¢ Create a Pull Request on GitHub"
                echo "  â€¢ Check CI/CD build status"
                echo ""
            fi
            
            rm -f "\$LOG_FILE" 2>/dev/null
            break
        fi
        
        sleep 1
        WAIT_COUNT=\$((WAIT_COUNT + 1))
    done
    
    if [ \$WAIT_COUNT -ge \$MAX_WAIT ]; then
        echo ""
        echo "âš ï¸  Background push is taking longer than expected."
        echo "   Check manually: git log --oneline -5"
        echo "   And verify: git push -n (dry run)"
        [ -f "\$LOG_FILE" ] && echo "   Log file: \$LOG_FILE"
        echo ""
    fi
fi

# Show reminder in all cases
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ğŸ’¡ REMINDER: Before merging to the parent branch, please run:"
echo "   \${BRANCH_TOOLS} cleanup-branch"
echo ""
echo "   This will restore workflow files and build.txt to their"
echo "   parent branch state, keeping the parent branch clean from"
echo "   unnecessary branch-specific changes."
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

exit \$EXIT_CODE

HOOK;
    }
}
